<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>graph explore</title>
<style>
  :root {
    --bg: #0f1115; --panel: #171923; --text: #e6e6e6; --muted: #9aa0a6;
    --btn: #2b2f3a; --btn-hover: #3a3f4d; --fixed-fill: #21314f;
    --accent: #7aa2f7; --dim: 0.18; --sel-thick: 6;
  }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font: 14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
  .wrap { display: grid; grid-template-columns: 360px 1fr; grid-template-rows: auto 1fr auto; gap: 10px; height: 100%; padding: 10px; box-sizing: border-box; }
  header { grid-column: 1 / -1; display: flex; align-items: center; justify-content: space-between; background: var(--panel); padding: 10px 14px; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.03); }
  header h1 { margin: 0; font-size: 16px; letter-spacing: .3px; color: #d7d7d7; }
  .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
  button, .file-btn { background: var(--btn); color: var(--text); border: 1px solid #272b35; border-radius: 10px; padding: 8px 10px; cursor: pointer; transition: background .15s ease; display: inline-flex; align-items: center; gap: 8px; }
  button:hover, .file-btn:hover { background: var(--btn-hover); }
  input[type="file"] { display: none; }

  #sidebar { background: var(--panel); border-radius: 12px; padding: 10px; box-shadow: 0 4px 16px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.03); display: flex; flex-direction: column; gap: 10px; min-height: 0; }
  textarea { width: 100%; min-height: 220px; resize: vertical; background: #0d0f14; color: var(--text); border: 1px solid #272b35; border-radius: 10px; padding: 10px; box-sizing: border-box; font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size: 12px; line-height: 1.35; }
  .hint { color: var(--muted); font-size: 12px; }

  .legend { display: grid; grid-template-columns: auto auto; gap: 6px 10px; align-items: center; background: #11131a; padding: 8px 10px; border-radius: 10px; border: 1px solid #272b35; }
  .badge { width: 16px; height: 16px; border-radius: 50%; border: 2px solid #202533; box-sizing: border-box; }
  .blue { background: #4ea1ff; } .red { background: #ff6b6b; } .green { background: #6ede8a; } .orange { background: #ffa94d; } .purple { background: #b28dff; }
  .num { color: #dcdcdc; font-weight: 600; font-size: 12px; }

  .canvas-wrap { position: relative; background: #0b0d12; border-radius: 12px; overflow: hidden; border: 1px solid #1e2230; }
  svg { width: 100%; height: 100%; display: block; }

  .toast { position: absolute; right: 10px; bottom: 10px; background: rgba(0,0,0,.6); border: 1px solid #2a2f3d; color: #d8dee9; padding: 6px 10px; border-radius: 8px; font-size: 12px; pointer-events: none; }

  .footer { grid-column: 1 / -1; display: flex; align-items: center; justify-content: space-between; gap: 10px; background: var(--panel); padding: 10px 14px; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.03); }
  .counts { color: #d7d7d7; } .truncate { color: #ffb454; }

  /* Slider area (wide to show color bars) */
  .match-slider { position: absolute; right: 6px; top: 10px; bottom: 10px; width: 170px; pointer-events: none; }
  .slider-rail { position: absolute; right: 20px; top: 0; bottom: 0; width: 36px; display: flex; align-items: stretch; justify-content: center; }
  .slider-rail input[type="range"] { pointer-events: auto; width: 36px; height: 100%; background: transparent; writing-mode: bt-lr; -webkit-appearance: slider-vertical; transform: scaleY(-1); }
  .slider-rail input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 6px; background: var(--accent); border: 1px solid #2a2f3d; }
  .slider-rail input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; border: 0; border-radius: 6px; background: var(--accent); }

  /* Tick “barcode” rows (left of rail) */
  .ticks { position: absolute; right: 86px; top: 10px; bottom: 10px; width: 84px; pointer-events: none; }
  .tick-row { position: absolute; left: 0; height: 8px; display: flex; gap: 3px; align-items: center; transform: translateY(-4px); }
  .tick-dot {
    width: 4px; height: 4px; border-radius: 50%;
    background: rgba(220,220,220,0.28);
    opacity: 0.9;
  }
  .tick-dot.hl {
    transform: scale(1.35);
    box-shadow: 0 0 6px var(--c), 0 0 2px var(--c);
    opacity: 1;
  }
  .tick-row.hidden { display: none; }

  /* “full” label at the top position */
  .tick-full {
    position: absolute; left: 0; transform: translateY(-6px);
    font-size: 11px; letter-spacing: 0.3px; color: rgba(220,220,220,0.5);
  }

  /* Interactivity */
  #edges { pointer-events: all; }
  .edge { pointer-events: stroke; cursor: pointer; }
  .mid-diamond { pointer-events: none; }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>graph explore</h1>
      <div class="controls">
        <button id="loadBtn">Load Graph</button>
        <button id="repositionBtn">Reposition</button>
        <button id="clearFixBtn">Clear Fixed</button>
        <button id="clearSelBtn">Clear Edges</button>
        <label class="file-btn" title="Upload a JSON file containing { &quot;graph&quot;: { &quot;(u,v,c1,c2)&quot;: weight, ... } }">
          <input type="file" id="fileInput" accept=".json,application/json" />
          Upload JSON
        </label>
        <span class="hint">Drag a vertex to fix it; click a fixed one to release. Click an edge to filter by that exact edge.</span>
      </div>
    </header>

    <aside id="sidebar">
      <textarea id="edgeInput" spellcheck="false">{
  "(0, 4, 1, 0)": 1.0,
  "(1, 3, 1, 1)": -1.0,
  "(1, 5, 2, 0)": 1.0,
  "(2, 5, 1, 0)": -1.0,
  "(3, 5, 1, 0)": 1.0,
  "(3, 7, 2, 0)": 1.0,
  "(5, 7, 0, 0)": -1.0,
  "(0, 2, 0, 0)": 1.0,
  "(1, 4, 0, 0)": -1.0,
  "(2, 7, 1, 0)": 1.0,
  "(4, 6, 0, 0)": 1.0,
  "(1, 3, 0, 1)": -1.0,
  "(3, 6, 0, 0)": 1.0,
  "(1, 6, 1, 0)": -1.0,
  "(6, 7, 0, 0)": 1.0
}</textarea>
      <div class="legend" aria-label="Color legend">
        <div class="badge blue"></div><div class="num">0</div>
        <div class="badge red"></div><div class="num">1</div>
        <div class="badge green"></div><div class="num">2</div>
        <div class="badge orange"></div><div class="num">3</div>
        <div class="badge purple"></div><div class="num">4</div>
        <div style="width:16px;height:16px;border:2px solid #aaa; transform: rotate(45deg);"></div>
        <div class="num">neg. weight</div>
      </div>
      <div class="hint">
        Input format: <code>{"(u, v, c1, c2)": weight, ...}</code> or a JSON file with top-level <code>"graph"</code>.
      </div>
    </aside>

    <main class="canvas-wrap">
      <svg id="svg" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice" aria-label="graph canvas">
        <defs>
          <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur in="SourceGraphic" stdDeviation="2.5" result="blur"/>
            <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
          </filter>
        </defs>
        <g id="edges"></g>
        <g id="nodes"></g>
      </svg>

      <div class="match-slider">
        <div class="ticks" id="ticks"></div>
        <div class="slider-rail">
          <input id="matchSlider" type="range" orient="vertical" min="0" max="0" step="1" value="0" title="Top = full graph; positions fixed and filtered by selection" />
        </div>
      </div>

      <div class="toast" id="toast" style="display:none;"></div>
    </main>

    <div class="footer">
      <div class="counts" id="counts">there are 0 perfect matchings for this graph</div>
      <div class="hint" id="truncateNote" style="display:none;">(<span class="truncate">truncated</span>)</div>
    </div>
  </div>

<script>
(() => {
  /* ---------- Elements ---------- */
  const svg = document.getElementById('svg');
  const gEdges = document.getElementById('edges');
  const gNodes = document.getElementById('nodes');
  const input = document.getElementById('edgeInput');
  const toast = document.getElementById('toast');
  const fileInput = document.getElementById('fileInput');
  const countsEl = document.getElementById('counts');
  const truncateNote = document.getElementById('truncateNote');
  const matchSlider = document.getElementById('matchSlider');
  const ticksEl = document.getElementById('ticks');

  /* ---------- Colors & constants ---------- */
  const colorMap = { 0:'#4ea1ff', 1:'#ff6b6b', 2:'#6ede8a', 3:'#ffa94d', 4:'#b28dff' };
  const NEUTRAL = '#9aa0a6';
  const FIXED_FILL = getComputedStyle(document.documentElement).getPropertyValue('--fixed-fill').trim() || '#21314f';
  const DIM_OPACITY = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dim')) || 0.18;
  const SEL_THICK = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sel-thick')) || 6;

  /* ---------- State ---------- */
  let nodes=[], edges=[], pairToEdges=new Map(), uniquePairs=new Set(), selectedEdges=new Set(), vertexOrder=[];
  // allData[k] = { eids:number[], colors:number[], key:string }
  let allData=[], filteredIndices=[], truncated=false;
  const MATCH_LIMIT=50000;

  // Physics
  let WIDTH=1200, HEIGHT=800; const PADDING=80;
  const SPRING_LENGTH=120, SPRING_K=0.08, CHARGE=14000;
  const DAMPING=0.85, MAX_SPEED=12; let temperature=1.0;
  let simRunning=false, dragging=null, lastTick=performance.now();

  /* ---------- Helpers ---------- */
  function showToast(msg, ms = 1400) { toast.textContent = msg; toast.style.display = 'block'; clearTimeout(showToast._t); showToast._t = setTimeout(()=>toast.style.display='none', ms); }
  function getBoundsFromSVG(){ const r=svg.getBoundingClientRect(); WIDTH=Math.max(400,Math.floor(r.width)); HEIGHT=Math.max(300,Math.floor(r.height)); }
  getBoundsFromSVG(); addEventListener('resize', getBoundsFromSVG);
  const pairKey=(a,b)=> a<b?`${a},${b}`:`${b},${a}`;
  const randomPos=()=>({ x:PADDING+Math.random()*(WIDTH-2*PADDING), y:PADDING+Math.random()*(HEIGHT-2*PADDING) });

  // SVG helpers
  function lineEl(x1,y1,x2,y2,stroke,width,opacity,eid,glow=false){
    const el=document.createElementNS('http://www.w3.org/2000/svg','line');
    el.setAttribute('x1',x1); el.setAttribute('y1',y1); el.setAttribute('x2',x2); el.setAttribute('y2',y2);
    el.setAttribute('stroke',stroke||NEUTRAL); el.setAttribute('stroke-width',width); el.setAttribute('stroke-linecap','round');
    el.setAttribute('opacity',String(opacity)); el.setAttribute('class','edge'); el.setAttribute('fill','none');
    el.setAttribute('data-eid', String(eid)); if (glow) el.setAttribute('filter','url(#softGlow)'); return el;
  }
  function quadPathEl(p0,p1,p2,stroke,width,opacity,eid,glow=false){
    const el=document.createElementNS('http://www.w3.org/2000/svg','path');
    el.setAttribute('d',`M ${p0.x} ${p0.y} Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`);
    el.setAttribute('stroke',stroke||NEUTRAL); el.setAttribute('stroke-width',width); el.setAttribute('stroke-linecap','round');
    el.setAttribute('fill','none'); el.setAttribute('opacity',String(opacity)); el.setAttribute('class','edge');
    el.setAttribute('data-eid', String(eid)); if (glow) el.setAttribute('filter','url(#softGlow)'); return el;
  }

  /* ---------- Parsing ---------- */
  function parseGraphObject(text){ let obj; try{ obj=JSON.parse(text); }catch{ throw new Error('Invalid JSON in textarea.'); } return parseEdgesFromMap(obj); }
  function parseEdgesFromMap(objMap){
    const E=[], Vset=new Set(); const valid=new Set([0,1,2,3,4]);
    for (const [k,w] of Object.entries(objMap)){
      const m=k.match(/^\s*\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*\)\s*$/);
      if (!m) throw new Error(`Bad edge key: ${k}`);
      const u=+m[1], v=+m[2], rawc1=+m[3], rawc2=+m[4];
      if (u===v) continue;
      const c1=valid.has(rawc1)?rawc1:-1, c2=valid.has(rawc2)?rawc2:-1;
      const wnum=Number(w); if(!Number.isFinite(wnum)) throw new Error(`Weight not a number for key ${k}`);
      E.push({u,v,c1,c2,w:wnum}); Vset.add(u); Vset.add(v);
    }
    return { V:Array.from(Vset).sort((a,b)=>a-b), E };
  }

  /* ---------- Build graph w/ multi-edge bookkeeping ---------- */
  function buildEdges(E){
    edges=E.map((e,i)=>({ id:i, ...e, pk:pairKey(e.u,e.v), ord:0, ordCount:1 }));
    pairToEdges=new Map(); uniquePairs=new Set();
    for (const ed of edges){ uniquePairs.add(ed.pk); if (!pairToEdges.has(ed.pk)) pairToEdges.set(ed.pk, []); pairToEdges.get(ed.pk).push(ed.id); }
    for (const list of pairToEdges.values()){ list.forEach((eid,j)=>{ edges[eid].ord=j; edges[eid].ordCount=list.length; }); }
  }
  function buildNodes(ids, reuse=false){
    const prev=new Map(nodes.map(n=>[n.id,n]));
    nodes = ids.map(id=>{
      if (reuse && prev.has(id)) { const p=prev.get(id); return { id, x:p.x, y:p.y, vx:0, vy:0, fixed:!!p.fixed }; }
      const r=randomPos(); return { id, x:r.x, y:r.y, vx:0, vy:0, fixed:false };
    });
    vertexOrder = ids.slice();
  }

  /* ---------- Perfect matchings (sorted by vertex coloring) ---------- */
  function computePairings(vertices,pairSet){
    const n=vertices.length; if (n%2) return {pairings:[], truncated:false};
    const idxOf=new Map(vertices.map((v,i)=>[v,i])); const invIdx=vertices;
    const adj=new Array(n).fill(0);
    for (const pk of pairSet){
      const [as,bs]=pk.split(','); const a=+as,b=+bs;
      if(!idxOf.has(a)||!idxOf.has(b)) continue;
      const i=idxOf.get(a), j=idxOf.get(b); adj[i]|=(1<<j); adj[j]|=(1<<i);
    }
    for (let i=0;i<n;i++) if ((adj[i]&((1<<n)-1))===0) return {pairings:[], truncated:false};
    const res=[]; const ALL=(1<<n)-1;
    (function dfs(mask,cur){
      if (res.length>=MATCH_LIMIT) return;
      if (!mask){ res.push(cur.slice()); return; }
      let i=0; while(((mask>>i)&1)===0) i++;
      const rest=mask&~(1<<i), opts=adj[i]&rest;
      for (let j=i+1;j<n;j++){
        if(((opts>>j)&1)===0) continue;
        cur.push(pairKey(invIdx[i],invIdx[j])); dfs(rest&~(1<<j),cur); cur.pop();
        if(res.length>=MATCH_LIMIT) return;
      }
    })(ALL,[]);
    return {pairings:res, truncated:res.length>=MATCH_LIMIT};
  }

  function expandAndSort(pairings){
    const out=[]; let cut=false;
    const vertexIndex=new Map(vertexOrder.map((v,i)=>[v,i]));
    for (const pairing of pairings){
      const lists=pairing.map(pk=>pairToEdges.get(pk)||[]); if (lists.some(a=>a.length===0)) continue;
      const cur=[];
      (function rec(i){
        if (cut) return;
        if (i===lists.length){
          const colors=new Array(vertexOrder.length).fill(0);
          for (const eid of cur){ const e=edges[eid]; colors[vertexIndex.get(e.u)]=e.c1; colors[vertexIndex.get(e.v)]=e.c2; }
          const key=colors.join('');
          out.push({ eids:cur.slice(), colors, key });
          if (out.length>=MATCH_LIMIT) cut=true;
          return;
        }
        for (const eid of lists[i]){ cur.push(eid); rec(i+1); cur.pop(); if(cut) return; }
      })(0);
      if (cut) break;
    }
    truncated=cut;
    out.sort((a,b)=> a.key<b.key?-1:a.key>b.key?1:0);
    return out;
  }

  /* ---------- Counts ---------- */
  function updateCounts(){
    const N=allData.length, M=filteredIndices.length, sel=selectedEdges.size;
    const base=`there ${N===1?'is':'are'} ${N} perfect matching${N===1?'':'s'} for this graph`;
    countsEl.textContent = base + (sel ? `, ${M} perfect matching${M===1?'':'s'} with the selected edges` : '');
    truncateNote.style.display = truncated ? '' : 'none';
  }

  /* ---------- Fixed-position ticks with highlight ---------- */
  function highlightedVertexSet() {
    // Vertices incident to any selected edge
    const s = new Set();
    if (selectedEdges.size === 0) return s;
    const vIndex = new Map(vertexOrder.map((v,i)=>[v,i]));
    for (const eid of selectedEdges) {
      const e = edges[eid]; if (!e) continue;
      s.add(vIndex.get(e.u)); s.add(vIndex.get(e.v));
    }
    return s;
  }

  function renderTicksFixed(){
    ticksEl.innerHTML='';
    const total = allData.length + 1; // include "full" at 0
    if (total<=1) return;

    const allowed = new Set(filteredIndices); // 1-based indices visible
    const hlVerts = highlightedVertexSet();

    for (let i=0;i<total;i++){
      const y = (i/(total-1))*100;
      if (i===0){
        const lab = document.createElement('div');
        lab.className = 'tick-full';
        lab.style.top = `${y}%`;
        lab.textContent = 'full';
        ticksEl.appendChild(lab);
        continue;
      }
      const row=document.createElement('div'); row.className='tick-row'; row.style.top=`${y}%`;

      const data = allData[i-1];
      for (let vi=0; vi<data.colors.length; vi++){
        const cval = data.colors[vi];
        const d=document.createElement('div'); d.className='tick-dot';
        const col = colorMap[cval] || 'rgba(220,220,220,0.28)';
        d.style.background = col;
        d.style.setProperty('--c', col);
        if (hlVerts.has(vi)) d.classList.add('hl'); // glow + brighten
        row.appendChild(d);
      }

      if (!allowed.has(i)) row.classList.add('hidden');
      ticksEl.appendChild(row);
    }
  }

  function applyMatchingSliderLimitsFixed(){
    // slider range fixed to full list
    matchSlider.min = 0;
    matchSlider.max = allData.length;

    // snap current value to nearest visible position (or 0)
    const allowed = new Set(filteredIndices);
    const v = +matchSlider.value;
    if (!(v===0 || allowed.has(v))){
      const snapped = nearestAllowed(v, allowed, allData.length);
      matchSlider.value = String(snapped);
    }
    renderTicksFixed();
  }

  function nearestAllowed(val, allowedSet, max){
    if (val===0 || allowedSet.has(val)) return val;
    for (let d=1; d<=max; d++){
      const left = val - d, right = val + d;
      if (left>=1 && allowedSet.has(left)) return left;
      if (right<=max && allowedSet.has(right)) return right;
    }
    return 0; // full
  }

  function refilterMatchings(){
    filteredIndices = [];
    if (selectedEdges.size===0){
      for (let i=1;i<=allData.length;i++) filteredIndices.push(i);
    } else {
      for (let i=0;i<allData.length;i++){
        const eids = allData[i].eids;
        let ok=true; for (const eid of selectedEdges){ if (!eids.includes(eid)){ ok=false; break; } }
        if (ok) filteredIndices.push(i+1);
      }
    }
    applyMatchingSliderLimitsFixed();
    updateCounts();
    draw();
  }

  /* ---------- Geometry & render ---------- */
  function curvedSplit(a,b,ord,ordCount){
    const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy)||0.001;
    const factor = (ordCount%2) ? (ord-(ordCount-1)/2) : (ord-(ordCount/2-0.5));
    const ux=-dy/dist, uy=dx/dist;
    const amp=Math.min(60, Math.max(18, 0.22*dist));
    const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    const c={x:mx+ux*amp*factor, y:my+uy*amp*factor};
    const A={x:(a.x+c.x)/2, y:(a.y+c.y)/2};
    const B={x:(c.x+b.x)/2, y:(c.y+b.y)/2};
    const M={x:(A.x+B.x)/2, y:(A.y+B.y)/2};
    return {p0:a,p1:c,p2:b,A,B,M};
  }

  function draw(){
    const byId=new Map(nodes.map(n=>[n.id,n]));
    const pos = +matchSlider.value;
    const allowed = new Set(filteredIndices);
    const showingMatching = (pos>0 && allowed.has(pos));
    const activeEdgeIds = new Set(showingMatching ? allData[pos-1].eids : []);

    // edges
    const fragE=document.createDocumentFragment();
    for (const e of edges){
      const a=byId.get(e.u), b=byId.get(e.v); if(!a||!b) continue;
      const isSelected=selectedEdges.has(e.id);
      const isInMatching=activeEdgeIds.has(e.id);
      const stroke1=colorMap[e.c1]||NEUTRAL, stroke2=colorMap[e.c2]||NEUTRAL;
      const opacity = showingMatching ? (isInMatching?0.98:DIM_OPACITY) : 0.95;
      const width = isSelected ? SEL_THICK : 2.5; const glow=isSelected;

      if (e.ordCount>1){
        const g=curvedSplit({x:a.x,y:a.y},{x:b.x,y:b.y},e.ord,e.ordCount);
        if (glow){ fragE.appendChild(quadPathEl(g.p0,g.A,g.M,stroke1,width+6,0.35,e.id,true)); fragE.appendChild(quadPathEl(g.M,g.B,g.p2,stroke2,width+6,0.35,e.id,true)); }
        fragE.appendChild(quadPathEl(g.p0,g.A,g.M,stroke1,width,opacity,e.id));
        fragE.appendChild(quadPathEl(g.M,g.B,g.p2,stroke2,width,opacity,e.id));
        if (e.w<0){ const d=document.createElementNS('http://www.w3.org/2000/svg','rect'); d.setAttribute('x',g.M.x-3.5); d.setAttribute('y',g.M.y-3.5); d.setAttribute('width',7); d.setAttribute('height',7); d.setAttribute('transform',`rotate(45 ${g.M.x} ${g.M.y})`); d.setAttribute('fill','none'); d.setAttribute('stroke','#cfcfcf'); d.setAttribute('stroke-width',1.8); d.setAttribute('opacity',String(opacity)); d.setAttribute('class','mid-diamond'); fragE.appendChild(d); }
      } else {
        const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
        if (glow){ fragE.appendChild(lineEl(a.x,a.y,mx,my,stroke1,width+6,0.35,e.id,true)); fragE.appendChild(lineEl(mx,my,b.x,b.y,stroke2,width+6,0.35,e.id,true)); }
        fragE.appendChild(lineEl(a.x,a.y,mx,my,stroke1,width,opacity,e.id));
        fragE.appendChild(lineEl(mx,my,b.x,b.y,stroke2,width,opacity,e.id));
        if (e.w<0){ const d=document.createElementNS('http://www.w3.org/2000/svg','rect'); d.setAttribute('x',mx-3.5); d.setAttribute('y',my-3.5); d.setAttribute('width',7); d.setAttribute('height',7); d.setAttribute('transform',`rotate(45 ${mx} ${my})`); d.setAttribute('fill','none'); d.setAttribute('stroke','#cfcfcf'); d.setAttribute('stroke-width',1.8); d.setAttribute('opacity',String(opacity)); d.setAttribute('class','mid-diamond'); fragE.appendChild(d); }
      }
    }
    gEdges.replaceChildren(fragE);

    // nodes
    const fragN=document.createDocumentFragment();
    for (const n of nodes){
      const c=document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx',n.x); c.setAttribute('cy',n.y); c.setAttribute('r',15);
      c.setAttribute('fill', n.fixed?FIXED_FILL:'#0b0d12'); c.setAttribute('stroke','#e5e7eb'); c.setAttribute('stroke-width', n.fixed?3.5:2.2); c.setAttribute('opacity', n.fixed?'1':'0.95'); fragN.appendChild(c);
      if (n.fixed){ const inner=document.createElementNS('http://www.w3.org/2000/svg','circle'); inner.setAttribute('cx',n.x); inner.setAttribute('cy',n.y); inner.setAttribute('r',10.5); inner.setAttribute('fill','none'); inner.setAttribute('stroke','#7aa2f7'); inner.setAttribute('stroke-width',1.6); inner.setAttribute('opacity','0.9'); fragN.appendChild(inner); }
      const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x',n.x); t.setAttribute('y',n.y+4); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','12'); t.setAttribute('fill','#f5f7fa'); t.setAttribute('font-weight','600'); t.textContent=String(n.id); fragN.appendChild(t);
      const hit=document.createElementNS('http://www.w3.org/2000/svg','circle'); hit.setAttribute('cx',n.x); hit.setAttribute('cy',n.y); hit.setAttribute('r',18); hit.setAttribute('fill','transparent'); hit.style.pointerEvents='all'; hit.addEventListener('mousedown', ev=>startDrag(ev,n)); hit.addEventListener('touchstart', ev=>{ ev.preventDefault(); startDrag(ev,n); }, {passive:false}); fragN.appendChild(hit);
    }
    gNodes.replaceChildren(fragN);
  }

  /* ---------- Edge selection ---------- */
  function findEdgeElementWithEid(ev){
    const path = (typeof ev.composedPath==='function') ? ev.composedPath() : (function(){ const arr=[]; let n=ev.target; while(n){ arr.push(n); n=n.parentNode; } return arr; })();
    for (const el of path){ if (el && el.getAttribute && el.getAttribute('data-eid')!=null) return el; }
    return null;
  }
  function onEdgePointer(ev){
    const el=findEdgeElementWithEid(ev); if(!el) return;
    const eid=parseInt(el.getAttribute('data-eid'),10); if(!Number.isFinite(eid)) return;
    if (selectedEdges.has(eid)) selectedEdges.delete(eid); else selectedEdges.add(eid);
    refilterMatchings(); // will re-render ticks with highlight
  }
  gEdges.addEventListener('pointerdown', onEdgePointer, {passive:true});
  gEdges.addEventListener('mousedown', onEdgePointer, {passive:true});

  /* ---------- Physics & drag ---------- */
  function tickLayout(dt){
    for (let i=0;i<nodes.length;i++){
      const ni=nodes[i];
      for (let j=i+1;j<nodes.length;j++){
        const nj=nodes[j];
        let dx=ni.x-nj.x, dy=ni.y-nj.y, d2=dx*dx+dy*dy+0.01, d=Math.sqrt(d2);
        let f=CHARGE/d2, fx=f*dx/d, fy=f*dy/d;
        if (!ni.fixed){ ni.vx+=fx*dt; ni.vy+=fy*dt; }
        if (!nj.fixed){ nj.vx-=fx*dt; nj.vy-=fy*dt; }
      }
    }
    for (const e of edges){
      const a=nodes.find(n=>n.id===e.u), b=nodes.find(n=>n.id===e.v); if(!a||!b) continue;
      let dx=b.x-a.x, dy=b.y-a.y, d=Math.sqrt(dx*dx+dy*dy)||0.001;
      let ext=d-SPRING_LENGTH, f=SPRING_K*ext, fx=f*dx/d, fy=f*dy/d;
      if(!a.fixed){ a.vx+= fx*dt; a.vy+= fy*dt; }
      if(!b.fixed){ b.vx+=-fx*dt; b.vy+=-fy*dt; }
    }
    for (const n of nodes){
      if (n.fixed){ n.vx=0; n.vy=0; continue; }
      n.vx*=DAMPING; n.vy*=DAMPING;
      n.x += Math.max(-MAX_SPEED, Math.min(MAX_SPEED, n.vx*temperature));
      n.y += Math.max(-MAX_SPEED, Math.min(MAX_SPEED, n.vy*temperature));
      n.x = Math.max(20, Math.min(WIDTH-20, n.x));
      n.y = Math.max(20, Math.min(HEIGHT-20, n.y));
    }
    temperature = Math.max(0.02, temperature*0.985);
  }
  function animate(){ if(!simRunning) return; const now=performance.now(), dt=Math.min(0.05,(now-lastTick)/1000); lastTick=now; tickLayout(dt); draw(); const moving = nodes.some(n=>!n.fixed && (Math.abs(n.vx)+Math.abs(n.vy) > 0.04)); if(!moving && temperature<=0.03 && !dragging){ simRunning=false; return; } requestAnimationFrame(animate); }
  function startSimulation(){ if(!simRunning){ simRunning=true; lastTick=performance.now(); requestAnimationFrame(animate); } }

  function svgPointFromEvent(ev){ const pt=svg.createSVGPoint(); const t=ev.touches&&ev.touches[0]; pt.x=t?t.clientX:ev.clientX; pt.y=t?t.clientY:ev.clientY; const ctm=svg.getScreenCTM().inverse(); return pt.matrixTransform(ctm); }
  function startDrag(ev,node){ const p=svgPointFromEvent(ev); dragging={node,dx:node.x-p.x,dy:node.y-p.y,moved:false}; temperature=Math.max(temperature,0.7); startSimulation(); addEventListener('mousemove', onDragMove); addEventListener('mouseup', onDragEnd); addEventListener('touchmove', onDragMove, {passive:false}); addEventListener('touchend', onDragEnd); }
  function onDragMove(ev){ if(!dragging) return; ev.preventDefault(); const p=svgPointFromEvent(ev); const n=dragging.node; const nx=p.x+dragging.dx, ny=p.y+dragging.dy; dragging.moved = dragging.moved || (Math.hypot(n.x-nx,n.y-ny)>2); n.x=nx; n.y=ny; draw(); }
  function onDragEnd(){ if(!dragging) return; const n=dragging.node; if (dragging.moved){ n.fixed=true; n.vx=0; n.vy=0; showToast(`Vertex ${n.id} fixed`); } else if (n.fixed){ n.fixed=false; showToast(`Vertex ${n.id} released`); } dragging=null; startSimulation(); draw(); removeEventListener('mousemove', onDragMove); removeEventListener('mouseup', onDragEnd); removeEventListener('touchmove', onDragMove); removeEventListener('touchend', onDragEnd); }

  /* ---------- Actions ---------- */
  function loadGraphCommon(V,E){
    buildNodes(V,true); buildEdges(E);
    temperature=1.0; draw(); startSimulation();

    const {pairings} = computePairings(V, uniquePairs);
    allData = expandAndSort(pairings);
    selectedEdges.clear();

    filteredIndices = []; for (let i=1;i<=allData.length;i++) filteredIndices.push(i);
    matchSlider.value = '0';
    applyMatchingSliderLimitsFixed();
    updateCounts();
    draw();
    showToast(`Loaded graph: ${V.length} vertices, ${E.length} edges. Found ${allData.length}${truncated?' (truncated)':''} perfect matchings.`);
  }
  function loadGraphFromInput(){ try{ const {V,E}=parseGraphObject(input.value); loadGraphCommon(V,E); }catch(e){ showToast(e.message||'Failed to load graph.',2400); } }
  async function handleFileSelection(ev){
    const file=ev.target.files&&ev.target.files[0]; if(!file) return;
    try{
      const text=await file.text(); const json=JSON.parse(text);
      if(!json || typeof json!=='object' || !json.graph || typeof json.graph!=='object') throw new Error("File must be JSON with a top-level 'graph' object.");
      input.value = JSON.stringify(json.graph, null, 2);
      const {V,E}=parseEdgesFromMap(json.graph); loadGraphCommon(V,E);
    }catch(e){ showToast(e.message||'Failed to parse file.',2400); }
    finally{ ev.target.value=''; }
  }

  function repositionNonFixed(){ for(const n of nodes) if(!n.fixed){ const p=randomPos(); n.x=p.x; n.y=p.y; n.vx=0; n.vy=0; } temperature=1.0; startSimulation(); draw(); showToast('Repositioned non-fixed vertices.'); }
  function clearFixedAll(){ for(const n of nodes) n.fixed=false; temperature=Math.max(temperature,0.7); startSimulation(); draw(); showToast('All vertices are now unfixed.'); }
  function clearSelectedEdges(){ if(selectedEdges.size===0) return; selectedEdges.clear(); refilterMatchings(); matchSlider.value='0'; draw(); showToast('Cleared selected edges.'); }

  // Slider input: snap to nearest visible position
  matchSlider.addEventListener('input', () => {
    const allowed = new Set(filteredIndices);
    const v = Math.round(+matchSlider.value);
    const snapped = nearestAllowed(v, allowed, allData.length);
    if (snapped !== v) matchSlider.value = String(snapped);
    draw();
  });

  document.getElementById('loadBtn').addEventListener('click', loadGraphFromInput);
  document.getElementById('repositionBtn').addEventListener('click', repositionNonFixed);
  document.getElementById('clearFixBtn').addEventListener('click', clearFixedAll);
  document.getElementById('clearSelBtn').addEventListener('click', clearSelectedEdges);
  fileInput.addEventListener('change', handleFileSelection);

  gEdges.addEventListener('pointerdown', onEdgePointer, {passive:true});
  gEdges.addEventListener('mousedown', onEdgePointer, {passive:true});

  /* kickoff */
  loadGraphFromInput();
})();
</script>
</body>
</html>
